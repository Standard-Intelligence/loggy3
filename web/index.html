<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loggy3 Session Viewer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            background-color: #fff;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-width: 900px;
            margin: 0 auto;
        }
        .drop-area {
            border: 3px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s;
        }
        .drop-area.highlight {
            border-color: #7289da;
            background-color: rgba(114, 137, 218, 0.1);
        }
        .file-input {
            display: none;
        }
        .browse-btn {
            background-color: #7289da;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        .session-container {
            margin-top: 30px;
            display: none;
        }
        .video-player {
            width: 100%;
            margin-bottom: 20px;
            border-radius: 4px;
            background-color: #000;
        }
        .chunks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .chunk-card {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 12px;
            background-color: #f9f9f9;
            position: relative;
        }
        .chunk-card.selected {
            border-color: #7289da;
            background-color: rgba(114, 137, 218, 0.1);
        }
        .chunk-card.active {
            border-color: #4caf50;
            background-color: rgba(76, 175, 80, 0.1);
        }
        .chunk-checkbox {
            position: absolute;
            top: 12px;
            right: 12px;
        }
        .chunk-thumbnail {
            width: 100%;
            height: 140px;
            object-fit: cover;
            border-radius: 4px;
            background-color: #ddd;
            cursor: pointer;
        }
        .chunk-info {
            margin-top: 8px;
            font-size: 14px;
        }
        .chunk-title {
            font-weight: bold;
            margin-bottom: 4px;
        }
        .chunk-meta {
            color: #666;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }
        .timeline {
            margin: 25px 0;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 6px;
            position: relative;
        }
        .timeline-inner {
            height: 40px;
            position: relative;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }
        .timeline-segment {
            position: absolute;
            height: 100%;
            background-color: #7289da;
            border-right: 1px solid #fff;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .timeline-segment.inactive {
            background-color: #ccc;
            opacity: 0.3;
        }
        .timeline-segment:hover {
            opacity: 1;
        }
        .timeline-segment.active {
            background-color: #4caf50;
        }
        .timeline-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background-color: red;
            z-index: 10;
        }
        .scrubber-container {
            margin: 15px 0;
        }
        #video-scrubber {
            width: 100%;
        }
        .btn {
            background-color: #7289da;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .btn-group {
            margin-top: 15px;
        }
        .warning {
            color: #ff6b6b;
            font-size: 13px;
            margin-top: 5px;
        }
        .info-text {
            color: #666;
            margin-bottom: 10px;
        }
        h1, h2, h3 {
            color: #7289da;
        }
        .displays-container {
            margin-top: 15px;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }
        .display-selector {
            margin-bottom: 15px;
        }
        .display-btn {
            background-color: #e0e0e0;
            border: none;
            padding: 6px 12px;
            margin-right: 8px;
            border-radius: 4px;
            cursor: pointer;
        }
        .display-btn.active {
            background-color: #7289da;
            color: white;
        }
        .tab-container {
            margin-top: 20px;
        }
        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #ddd;
        }
        .tab-button {
            padding: 10px 15px;
            background: none;
            border: none;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        .tab-button.active {
            border-bottom-color: #7289da;
            color: #7289da;
            font-weight: bold;
        }
        .tab-content {
            display: none;
            padding: 15px 0;
        }
        .tab-content.active {
            display: block;
        }
        .keypress-log, .mouse-log {
            max-height: 300px;
            overflow-y: auto;
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #7289da;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 2s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .session-info {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 6px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Loggy3 Session Viewer</h1>
        <p class="info-text">Upload a Loggy3 session folder or drop it here to view and edit your recordings.</p>
        
        <div id="drop-area" class="drop-area">
            <p>Drag and drop a session folder here</p>
            <p>or</p>
            <input type="file" id="directory-input" class="file-input" webkitdirectory directory multiple>
            <button class="browse-btn" id="browse-btn">Browse Folders</button>
            <p class="warning">Note: This is a local interface, files are not uploaded to any server.</p>
        </div>
        
        <div id="session-container" class="session-container">
            <div id="session-info" class="session-info">
                <h3>Session Information</h3>
                <div id="session-details"></div>
            </div>
            
            <div class="displays-container">
                <h3>Display Selection</h3>
                <div id="display-selector" class="display-selector">
                    <!-- Display buttons will be added here -->
                </div>
            </div>
            
            <h2>Video Preview</h2>
            <video id="video-player" class="video-player" controls>
                Your browser does not support the video tag.
            </video>
            
            <div class="timeline" id="timeline-container">
                <div class="timeline-inner" id="timeline">
                    <!-- Timeline segments will be added here -->
                </div>
                <div class="timeline-marker" id="timeline-marker" style="left: 0;"></div>
            </div>
            
            <div class="scrubber-container">
                <input type="range" min="0" max="100" value="0" id="video-scrubber">
            </div>
            
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="chunks-tab">Chunks</button>
                    <button class="tab-button" data-tab="keypresses-tab">Keypresses</button>
                    <button class="tab-button" data-tab="mouse-tab">Mouse Activity</button>
                </div>
                
                <div class="tab-content active" id="chunks-tab">
                    <h3>Video Chunks</h3>
                    <p class="info-text">Select which chunks to include in your edit:</p>
                    <div id="chunks-grid" class="chunks-grid">
                        <!-- Chunk cards will be added here -->
                    </div>
                </div>
                
                <div class="tab-content" id="keypresses-tab">
                    <h3>Keypress Log</h3>
                    <div id="keypress-log" class="keypress-log">
                        Select a chunk to view keypress data.
                    </div>
                </div>
                
                <div class="tab-content" id="mouse-tab">
                    <h3>Mouse Activity</h3>
                    <div id="mouse-log" class="mouse-log">
                        Select a chunk to view mouse activity data.
                    </div>
                </div>
            </div>
            
            <div class="btn-group">
                <button id="play-selected" class="btn">Play Selected Chunks</button>
                <button id="download-btn" class="btn">Download Edited Video</button>
                <button id="select-all-btn" class="btn">Select All</button>
                <button id="deselect-all-btn" class="btn">Deselect All</button>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const dropArea = document.getElementById('drop-area');
        const directoryInput = document.getElementById('directory-input');
        const browseBtn = document.getElementById('browse-btn');
        const sessionContainer = document.getElementById('session-container');
        const sessionDetails = document.getElementById('session-details');
        const displaySelector = document.getElementById('display-selector');
        const videoPlayer = document.getElementById('video-player');
        const videoScrubber = document.getElementById('video-scrubber');
        const chunksGrid = document.getElementById('chunks-grid');
        const keypressLog = document.getElementById('keypress-log');
        const mouseLog = document.getElementById('mouse-log');
        const timeline = document.getElementById('timeline');
        const timelineMarker = document.getElementById('timeline-marker');
        const playSelectedBtn = document.getElementById('play-selected');
        const downloadBtn = document.getElementById('download-btn');
        const selectAllBtn = document.getElementById('select-all-btn');
        const deselectAllBtn = document.getElementById('deselect-all-btn');
        
        // Session data
        let sessionData = {
            name: '',
            chunks: [],
            displays: [],
            currentDisplay: null,
            selectedChunks: new Set(),
            activeChunk: null,
            keypressLogs: new Map(), // Map of chunk_id -> keypress log content
            mouseLogs: new Map(),    // Map of chunk_id -> mouse log content
        };
        
        // Setup tab navigation
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                
                button.classList.add('active');
                document.getElementById(button.dataset.tab).classList.add('active');
            });
        });
        
        // Event listeners for drag and drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight() {
            dropArea.classList.add('highlight');
        }
        
        function unhighlight() {
            dropArea.classList.remove('highlight');
        }
        
        // Handle folder drop
        dropArea.addEventListener('drop', handleDrop, false);
        
        function handleDrop(e) {
            const items = e.dataTransfer.items;
            if (items && items.length > 0) {
                // Use the webkitGetAsEntry API to get folder entries
                const entries = Array.from(items)
                    .map(item => item.webkitGetAsEntry())
                    .filter(entry => entry && entry.isDirectory);
                
                if (entries.length > 0) {
                    processSessionFolder(entries[0]);
                } else {
                    alert('Please drop a Loggy3 session folder');
                }
            }
        }
        
        // Handle folder selection via button
        browseBtn.addEventListener('click', () => {
            directoryInput.click();
        });
        
        directoryInput.addEventListener('change', () => {
            const files = Array.from(directoryInput.files);
            if (files.length > 0) {
                // Process all files from the directory input
                processSessionFiles(files);
            }
        });
        
        // Process a session folder entry
        function processSessionFolder(folderEntry) {
            // Visual feedback that processing is happening
            showLoader();
            
            // Read the entire directory structure
            const readEntries = (entry, path = '') => {
                return new Promise((resolve, reject) => {
                    if (entry.isFile) {
                        entry.file(file => {
                            // Add path information to the file
                            file.relativePath = path + file.name;
                            resolve(file);
                        }, reject);
                    } else if (entry.isDirectory) {
                        const dirReader = entry.createReader();
                        const readBatch = () => {
                            dirReader.readEntries(entries => {
                                if (entries.length > 0) {
                                    // Process this batch then read the next batch
                                    Promise.all(entries.map(e => readEntries(e, path + entry.name + '/')))
                                        .then(files => {
                                            // Flatten the array of file arrays
                                            const flatFiles = files.reduce((acc, val) => acc.concat(val), []);
                                            readBatch(); // Read next batch of entries
                                            resolve(flatFiles);
                                        })
                                        .catch(reject);
                                } else {
                                    // No more entries, we're done with this directory
                                    resolve([]);
                                }
                            }, reject);
                        };
                        readBatch();
                    }
                });
            };
            
            readEntries(folderEntry)
                .then(files => {
                    processSessionFiles(files);
                })
                .catch(error => {
                    hideLoader();
                    console.error('Error reading folder:', error);
                    alert('Error reading the session folder: ' + error.message);
                });
        }
        
        // Process all session files
        function processSessionFiles(files) {
            // Extract session name from the first file path
            if (files.length > 0) {
                const firstFilePath = files[0].relativePath || files[0].webkitRelativePath;
                const pathParts = firstFilePath.split('/');
                if (pathParts.length > 1) {
                    sessionData.name = pathParts[0];
                }
            }
            
            // Find display info JSON
            const displayInfoFile = files.find(file => 
                (file.name === 'display_info.json' || 
                file.name.endsWith('/display_info.json')));
            
            if (displayInfoFile) {
                // Read display info
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const displayInfo = JSON.parse(e.target.result);
                        sessionData.displays = displayInfo;
                        
                        // Process chunk folders and video files
                        processChunkFolders(files);
                    } catch (error) {
                        console.error('Error parsing display info:', error);
                        alert('Error parsing display_info.json file: ' + error.message);
                    }
                };
                reader.readAsText(displayInfoFile);
            } else {
                // No display info found, but continue processing chunks
                processChunkFolders(files);
            }
        }
        
        // Process chunk folders
        function processChunkFolders(files) {
            // Extract chunk folders pattern
            const chunkRegex = /chunk_(\d+)/;
            const chunkFolders = new Set();
            
            files.forEach(file => {
                const path = file.relativePath || file.webkitRelativePath;
                const match = path.match(chunkRegex);
                if (match) {
                    chunkFolders.add(match[0]);
                }
            });
            
            // Sort chunks numerically
            const sortedChunks = Array.from(chunkFolders).sort((a, b) => {
                const aNum = parseInt(a.match(/\d+/)[0]);
                const bNum = parseInt(b.match(/\d+/)[0]);
                return aNum - bNum;
            });
            
            // Process each chunk
            sessionData.chunks = [];
            
            sortedChunks.forEach(chunkFolder => {
                const chunkIndex = parseInt(chunkFolder.match(/\d+/)[0]);
                
                // Find all display folders for this chunk
                const displayFolders = new Set();
                files.forEach(file => {
                    const path = file.relativePath || file.webkitRelativePath;
                    if (path.includes(chunkFolder + '/display_')) {
                        const displayPathParts = path.split('/');
                        const displayFolderIndex = displayPathParts.findIndex(part => part.startsWith('display_'));
                        if (displayFolderIndex !== -1) {
                            displayFolders.add(displayPathParts[displayFolderIndex]);
                        }
                    }
                });
                
                // Process each display folder in this chunk
                const displaysInChunk = [];
                displayFolders.forEach(displayFolder => {
                    // Extract display ID
                    const displayIdMatch = displayFolder.match(/display_(\d+)/);
                    const displayId = displayIdMatch ? parseInt(displayIdMatch[1]) : null;
                    
                    // Find video.mp4 for this display
                    const videoFile = files.find(file => {
                        const path = file.relativePath || file.webkitRelativePath;
                        return path.includes(`${chunkFolder}/${displayFolder}/video.mp4`);
                    });
                    
                    if (videoFile) {
                        displaysInChunk.push({
                            id: displayId,
                            folderName: displayFolder,
                            videoFile: videoFile,
                            url: URL.createObjectURL(videoFile)
                        });
                    }
                });
                
                // Find keypress and mouse logs for this chunk
                const keypressLogFile = files.find(file => {
                    const path = file.relativePath || file.webkitRelativePath;
                    return path.includes(`${chunkFolder}/keypresses.log`);
                });
                
                const mouseLogFile = files.find(file => {
                    const path = file.relativePath || file.webkitRelativePath;
                    return path.includes(`${chunkFolder}/mouse.log`);
                });
                
                // Add chunk to session data
                sessionData.chunks.push({
                    index: chunkIndex,
                    folderName: chunkFolder,
                    displays: displaysInChunk,
                    keypressLogFile: keypressLogFile,
                    mouseLogFile: mouseLogFile,
                    selected: true // Default to selected
                });
                
                sessionData.selectedChunks.add(chunkIndex);
            });
            
            // Sort chunks by index
            sessionData.chunks.sort((a, b) => a.index - b.index);
            
            // Set default display if available
            if (sessionData.displays.length > 0) {
                // Find main display or use the first one
                const mainDisplay = sessionData.displays.find(d => d.is_primary) || sessionData.displays[0];
                sessionData.currentDisplay = mainDisplay.id;
            } else if (sessionData.chunks.length > 0 && sessionData.chunks[0].displays.length > 0) {
                // If no display info, use the first display from the first chunk
                sessionData.currentDisplay = sessionData.chunks[0].displays[0].id;
            }
            
            // Render the session interface
            renderSessionInterface();
        }
        
        // Render the main session interface
        function renderSessionInterface() {
            // Hide loader and show session container
            hideLoader();
            sessionContainer.style.display = 'block';
            
            // Render session details
            renderSessionInfo();
            
            // Render display selector
            renderDisplaySelector();
            
            // Render chunks grid
            renderChunksGrid();
            
            // Render timeline
            renderTimeline();
            
            // Load the first video if available
            loadFirstVideoForCurrentDisplay();
            
            // Set up event listeners
            setupEventListeners();
        }
        
        // Render session information
        function renderSessionInfo() {
            let html = `<p><strong>Session Name:</strong> ${sessionData.name}</p>`;
            html += `<p><strong>Number of Chunks:</strong> ${sessionData.chunks.length}</p>`;
            html += `<p><strong>Displays:</strong> ${sessionData.displays.length}</p>`;
            
            sessionDetails.innerHTML = html;
        }
        
        // Render display selector
        function renderDisplaySelector() {
            displaySelector.innerHTML = '';
            
            // Create buttons for each display
            if (sessionData.displays.length > 0) {
                sessionData.displays.forEach(display => {
                    const btn = document.createElement('button');
                    btn.className = 'display-btn';
                    btn.dataset.displayId = display.id;
                    btn.textContent = display.title || `Display ${display.id}`;
                    
                    if (display.id === sessionData.currentDisplay) {
                        btn.classList.add('active');
                    }
                    
                    btn.addEventListener('click', () => {
                        // Update current display
                        sessionData.currentDisplay = display.id;
                        
                        // Update active state
                        document.querySelectorAll('.display-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        // Reload chunks grid for the new display
                        renderChunksGrid();
                        
                        // Load first video for the new display
                        loadFirstVideoForCurrentDisplay();
                    });
                    
                    displaySelector.appendChild(btn);
                });
            } else {
                // If no display info, use display IDs from chunks
                const displayIds = new Set();
                sessionData.chunks.forEach(chunk => {
                    chunk.displays.forEach(display => {
                        displayIds.add(display.id);
                    });
                });
                
                Array.from(displayIds).forEach(displayId => {
                    const btn = document.createElement('button');
                    btn.className = 'display-btn';
                    btn.dataset.displayId = displayId;
                    btn.textContent = `Display ${displayId}`;
                    
                    if (displayId === sessionData.currentDisplay) {
                        btn.classList.add('active');
                    }
                    
                    btn.addEventListener('click', () => {
                        // Update current display
                        sessionData.currentDisplay = displayId;
                        
                        // Update active state
                        document.querySelectorAll('.display-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        // Reload chunks grid for the new display
                        renderChunksGrid();
                        
                        // Load first video for the new display
                        loadFirstVideoForCurrentDisplay();
                    });
                    
                    displaySelector.appendChild(btn);
                });
            }
        }
        
        // Render chunks grid
        function renderChunksGrid() {
            chunksGrid.innerHTML = '';
            
            sessionData.chunks.forEach(chunk => {
                // Find the video for the current display
                const displayVideo = chunk.displays.find(d => d.id === sessionData.currentDisplay);
                if (!displayVideo) return; // Skip if no video for this display
                
                // Create chunk card
                const card = document.createElement('div');
                card.className = 'chunk-card';
                card.dataset.chunkIndex = chunk.index;
                
                if (sessionData.selectedChunks.has(chunk.index)) {
                    card.classList.add('selected');
                }
                
                if (sessionData.activeChunk === chunk.index) {
                    card.classList.add('active');
                }
                
                // Create chunk checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'chunk-checkbox';
                checkbox.checked = sessionData.selectedChunks.has(chunk.index);
                checkbox.dataset.chunkIndex = chunk.index;
                checkbox.addEventListener('change', (e) => {
                    const index = parseInt(e.target.dataset.chunkIndex);
                    if (e.target.checked) {
                        sessionData.selectedChunks.add(index);
                        card.classList.add('selected');
                    } else {
                        sessionData.selectedChunks.delete(index);
                        card.classList.remove('selected');
                    }
                    
                    // Update timeline
                    updateTimelineSegments();
                });
                
                // Create thumbnail (will capture video frame)
                const thumbnail = document.createElement('div');
                thumbnail.className = 'chunk-thumbnail';
                thumbnail.style.backgroundColor = '#000';
                thumbnail.style.position = 'relative';
                thumbnail.style.cursor = 'pointer';
                thumbnail.dataset.chunkIndex = chunk.index;
                
                // Create a temporary video to grab thumbnail
                const tempVideo = document.createElement('video');
                tempVideo.src = displayVideo.url;
                tempVideo.muted = true;
                tempVideo.style.display = 'none';
                
                // Create play icon overlay
                const playIcon = document.createElement('div');
                playIcon.style.position = 'absolute';
                playIcon.style.top = '50%';
                playIcon.style.left = '50%';
                playIcon.style.transform = 'translate(-50%, -50%)';
                playIcon.style.color = 'white';
                playIcon.style.fontSize = '30px';
                playIcon.innerHTML = 'â–¶';
                playIcon.style.opacity = '0.7';
                
                thumbnail.appendChild(playIcon);
                
                // Handle thumbnail click to play this chunk
                thumbnail.addEventListener('click', () => {
                    playChunk(chunk.index);
                });
                
                // Try to get thumbnail when metadata is loaded
                tempVideo.addEventListener('loadeddata', () => {
                    tempVideo.currentTime = 0.5; // Seek to 0.5 seconds
                });
                
                tempVideo.addEventListener('seeked', () => {
                    // Create canvas to capture the frame
                    const canvas = document.createElement('canvas');
                    canvas.width = tempVideo.videoWidth;
                    canvas.height = tempVideo.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(tempVideo, 0, 0, canvas.width, canvas.height);
                    
                    // Set thumbnail background
                    thumbnail.style.backgroundImage = `url(${canvas.toDataURL()})`;
                    thumbnail.style.backgroundSize = 'cover';
                    thumbnail.style.backgroundPosition = 'center';
                    
                    // Remove temporary video
                    document.body.removeChild(tempVideo);
                });
                
                // Append temporary video to body to load it
                document.body.appendChild(tempVideo);
                
                // Create chunk info section
                const chunkInfo = document.createElement('div');
                chunkInfo.className = 'chunk-info';
                
                const chunkTitle = document.createElement('div');
                chunkTitle.className = 'chunk-title';
                chunkTitle.textContent = `Chunk ${chunk.index}`;
                
                const chunkMeta = document.createElement('div');
                chunkMeta.className = 'chunk-meta';
                
                const chunkDuration = document.createElement('span');
                chunkDuration.textContent = 'Loading...';
                
                // Get video duration
                const durationVideo = document.createElement('video');
                durationVideo.src = displayVideo.url;
                durationVideo.addEventListener('loadedmetadata', () => {
                    const minutes = Math.floor(durationVideo.duration / 60);
                    const seconds = Math.floor(durationVideo.duration % 60);
                    chunkDuration.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                });
                
                chunkMeta.appendChild(chunkDuration);
                
                chunkInfo.appendChild(chunkTitle);
                chunkInfo.appendChild(chunkMeta);
                
                // Assemble card
                card.appendChild(checkbox);
                card.appendChild(thumbnail);
                card.appendChild(chunkInfo);
                
                chunksGrid.appendChild(card);
            });
        }
        
        // Render timeline
        function renderTimeline() {
            timeline.innerHTML = '';
            
            const totalChunks = sessionData.chunks.length;
            if (totalChunks === 0) return;
            
            sessionData.chunks.forEach(chunk => {
                const segmentWidth = (100 / totalChunks);
                const segment = document.createElement('div');
                segment.className = 'timeline-segment';
                segment.dataset.chunkIndex = chunk.index;
                segment.style.width = `${segmentWidth}%`;
                segment.style.left = `${(chunk.index / totalChunks) * 100}%`;
                
                // Set initial state based on selection
                if (!sessionData.selectedChunks.has(chunk.index)) {
                    segment.classList.add('inactive');
                }
                
                // Handle click on timeline segment
                segment.addEventListener('click', () => {
                    playChunk(chunk.index);
                });
                
                timeline.appendChild(segment);
            });
        }
        
        // Update timeline segments based on selected chunks
        function updateTimelineSegments() {
            document.querySelectorAll('.timeline-segment').forEach(segment => {
                const chunkIndex = parseInt(segment.dataset.chunkIndex);
                if (sessionData.selectedChunks.has(chunkIndex)) {
                    segment.classList.remove('inactive');
                } else {
                    segment.classList.add('inactive');
                }
                
                if (sessionData.activeChunk === chunkIndex) {
                    segment.classList.add('active');
                } else {
                    segment.classList.remove('active');
                }
            });
        }
        
        // Update timeline marker position
        function updateTimelineMarker(percent) {
            timelineMarker.style.left = `${percent}%`;
        }
        
        // Load the first video for the current display
        function loadFirstVideoForCurrentDisplay() {
            // Find first selected chunk with the current display
            for (const chunk of sessionData.chunks) {
                if (sessionData.selectedChunks.has(chunk.index)) {
                    const displayVideo = chunk.displays.find(d => d.id === sessionData.currentDisplay);
                    if (displayVideo) {
                        videoPlayer.src = displayVideo.url;
                        videoPlayer.load();
                        sessionData.activeChunk = chunk.index;
                        break;
                    }
                }
            }
            
            // Update UI to show active chunk
            updateActiveChunkUI();
        }
        
        // Play a specific chunk
        function playChunk(chunkIndex) {
            const chunk = sessionData.chunks.find(c => c.index === chunkIndex);
            if (!chunk) return;
            
            const displayVideo = chunk.displays.find(d => d.id === sessionData.currentDisplay);
            if (!displayVideo) return;
            
            // Update active chunk
            sessionData.activeChunk = chunkIndex;
            
            // Load and play the video
            videoPlayer.src = displayVideo.url;
            videoPlayer.load();
            videoPlayer.play();
            
            // Update UI
            updateActiveChunkUI();
            
            // Load log files for this chunk
            loadLogFilesForChunk(chunk);
        }
        
        // Update UI to reflect the active chunk
        function updateActiveChunkUI() {
            // Update chunk cards
            document.querySelectorAll('.chunk-card').forEach(card => {
                const cardChunkIndex = parseInt(card.dataset.chunkIndex);
                if (cardChunkIndex === sessionData.activeChunk) {
                    card.classList.add('active');
                } else {
                    card.classList.remove('active');
                }
            });
            
            // Update timeline segments
            updateTimelineSegments();
        }
        
        // Load keypress and mouse logs for a chunk
        function loadLogFilesForChunk(chunk) {
            // Check if we already loaded these logs
            if (sessionData.keypressLogs.has(chunk.index)) {
                updateLogDisplay(keypressLog, sessionData.keypressLogs.get(chunk.index));
            } else if (chunk.keypressLogFile) {
                // Load keypress log
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    sessionData.keypressLogs.set(chunk.index, content);
                    updateLogDisplay(keypressLog, content);
                };
                reader.readAsText(chunk.keypressLogFile);
            } else {
                updateLogDisplay(keypressLog, "No keypress log available for this chunk.");
            }
            
            if (sessionData.mouseLogs.has(chunk.index)) {
                updateLogDisplay(mouseLog, sessionData.mouseLogs.get(chunk.index));
            } else if (chunk.mouseLogFile) {
                // Load mouse log
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    sessionData.mouseLogs.set(chunk.index, content);
                    updateLogDisplay(mouseLog, content);
                };
                reader.readAsText(chunk.mouseLogFile);
            } else {
                updateLogDisplay(mouseLog, "No mouse log available for this chunk.");
            }
        }
        
        // Update log display with content
        function updateLogDisplay(element, content) {
            // Limit display to first 1000 lines to avoid browser slowdowns
            let lines = content.split('\n');
            if (lines.length > 1000) {
                lines = lines.slice(0, 1000);
                element.innerHTML = lines.join('\n') + '\n\n[Log truncated for display - too many lines]';
            } else {
                element.innerHTML = content;
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Video player current time update
            videoPlayer.addEventListener('timeupdate', () => {
                // Update scrubber
                if (videoPlayer.duration) {
                    const percent = (videoPlayer.currentTime / videoPlayer.duration) * 100;
                    videoScrubber.value = percent;
                    
                    // Calculate global progress in the current chunk
                    if (sessionData.activeChunk !== null) {
                        const chunkCount = sessionData.chunks.length;
                        
                        // Calculate normalized time for the entire session
                        const normalizedTime = (sessionData.activeChunk + (videoPlayer.currentTime / videoPlayer.duration)) / chunkCount;
                        
                        // Update timeline marker
                        updateTimelineMarker(normalizedTime * 100);
                    }
                }
            });
            
            // Video scrubber input
            videoScrubber.addEventListener('input', () => {
                const time = (videoScrubber.value / 100) * videoPlayer.duration;
                videoPlayer.currentTime = time;
            });
            
            // Video ended - play next chunk if available
            videoPlayer.addEventListener('ended', () => {
                playNextChunk();
            });
            
            // Play selected chunks button
            playSelectedBtn.addEventListener('click', () => {
                playSelectedChunks();
            });
            
            // Download button
            downloadBtn.addEventListener('click', () => {
                alert('In a real implementation, this would combine the selected chunks into a single video file for download.');
            });
            
            // Select All button
            selectAllBtn.addEventListener('click', () => {
                document.querySelectorAll('.chunk-checkbox').forEach(checkbox => {
                    checkbox.checked = true;
                    const chunkIndex = parseInt(checkbox.dataset.chunkIndex);
                    sessionData.selectedChunks.add(chunkIndex);
                    
                    // Update card UI
                    const card = checkbox.closest('.chunk-card');
                    if (card) card.classList.add('selected');
                });
                
                // Update timeline
                updateTimelineSegments();
            });
            
            // Deselect All button
            deselectAllBtn.addEventListener('click', () => {
                document.querySelectorAll('.chunk-checkbox').forEach(checkbox => {
                    checkbox.checked = false;
                    const chunkIndex = parseInt(checkbox.dataset.chunkIndex);
                    sessionData.selectedChunks.delete(chunkIndex);
                    
                    // Update card UI
                    const card = checkbox.closest('.chunk-card');
                    if (card) card.classList.remove('selected');
                });
                
                // Update timeline
                updateTimelineSegments();
            });
        }
        
        // Play next chunk after current one ends
        function playNextChunk() {
            if (sessionData.activeChunk === null) return;
            
            // Find the next selected chunk after the current one
            const currentIndex = sessionData.chunks.findIndex(c => c.index === sessionData.activeChunk);
            if (currentIndex === -1) return;
            
            // Look for next selected chunk
            for (let i = currentIndex + 1; i < sessionData.chunks.length; i++) {
                const chunk = sessionData.chunks[i];
                if (sessionData.selectedChunks.has(chunk.index)) {
                    playChunk(chunk.index);
                    return;
                }
            }
            
            // If we get here, there are no more chunks to play
            console.log('End of selected chunks reached');
        }
        
        // Play all selected chunks in sequence
        function playSelectedChunks() {
            // Find the first selected chunk
            const firstSelectedChunk = sessionData.chunks.find(chunk => 
                sessionData.selectedChunks.has(chunk.index));
                
            if (firstSelectedChunk) {
                playChunk(firstSelectedChunk.index);
            } else {
                alert('Please select at least one chunk to play');
            }
        }
        
        // Show loader animation
        function showLoader() {
            // Create loader element if it doesn't exist
            let loader = document.getElementById('loader');
            if (!loader) {
                loader = document.createElement('div');
                loader.id = 'loader';
                loader.className = 'loader';
                document.body.appendChild(loader);
            }
            loader.style.display = 'block';
        }
        
        // Hide loader animation
        function hideLoader() {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.style.display = 'none';
            }
        }
    </script>
</body>
</html>